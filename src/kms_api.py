"""This module provides the Key Management System (KMS) API for generating, storing,distributing, rotating, and revoking cryptographic keys."""import osimport jsonfrom cryptography.fernet import Fernetfrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMACfrom cryptography.hazmat.backends import default_backendimport base64from src.pqc import Kyber, Dilithiumfrom src.hybrid_crypto import HybridCryptoclass KMS:    """    Manages cryptographic keys for the framework.    """    def __init__(self, master_password: str = "supersecretpassword"):        self.master_password = master_password.encode('utf-8')        self.salt = b'\x8d\x9b\x1c\x0f\x1e\x0c\x1b\x0a\x1d\x0b\x1f\x0d\x1a\x0e\x19\x09' # Fixed salt for simplicity in prototype        self.fernet = self._derive_fernet_key()        self.hybrid_crypto = HybridCrypto()        self.key_store_path = "./kms_key_store.json"        self._load_key_store()    def _derive_fernet_key(self):        kdf = PBKDF2HMAC(            algorithm=hashes.SHA256(),            length=32,            salt=self.salt,            iterations=100000,            backend=default_backend()        )        key = base64.urlsafe_b64encode(kdf.derive(self.master_password))        return Fernet(key)    def _load_key_store(self):        if os.path.exists(self.key_store_path):            with open(self.key_store_path, 'r') as f:                encrypted_data = f.read()            try:                decrypted_data = self.fernet.decrypt(encrypted_data.encode('utf-8')).decode('utf-8')                self.key_store = json.loads(decrypted_data)            except Exception as e:                print(f"Error loading key store: {e}. Initializing empty key store.")                self.key_store = {}        else:            self.key_store = {}    def _save_key_store(self):        encrypted_data = self.fernet.encrypt(json.dumps(self.key_store).encode('utf-8'))        with open(self.key_store_path, 'w') as f:            f.write(encrypted_data.decode('utf-8'))    def generate_pqc_key_pair(self, key_id: str, algorithm: str = "Kyber") -> dict:        """        Generates and stores a PQC key pair.        """        if algorithm == "Kyber":            pqc_instance = Kyber()        elif algorithm == "Dilithium":            pqc_instance = Dilithium()        else:            raise ValueError("Unsupported PQC algorithm.")        public_key, private_key = pqc_instance.generate_keypair()                self.key_store[key_id] = {            "algorithm": algorithm,            "public_key": public_key.hex(),            "private_key": private_key.hex(), # Storing private key for prototype, secure storage needed            "type": "PQC",            "status": "active"        }        self._save_key_store()        return {"public_key": public_key, "private_key": private_key}    def get_key(self, key_id: str) -> dict:        """        Retrieves a key from the key store.        """        key_data = self.key_store.get(key_id)        if key_data:            return {                "algorithm": key_data["algorithm"],                "public_key": bytes.fromhex(key_data["public_key"]),                "private_key": bytes.fromhex(key_data["private_key"]),                "type": key_data["type"],                "status": key_data["status"]            }        return None    def generate_symmetric_key(self, key_id: str, key_length: int = 32) -> bytes:        """        Generates and stores a symmetric key (e.g., AES).        """        symmetric_key = os.urandom(key_length)        self.key_store[key_id] = {            "algorithm": "AES",            "key": symmetric_key.hex(),            "type": "symmetric",            "status": "active"        }        self._save_key_store()        return symmetric_key    def rotate_key(self, key_id: str):        """        Rotates an existing key by generating a new one and marking the old as inactive.        """        if key_id not in self.key_store:            raise ValueError(f"Key with ID {key_id} not found.")        old_key_data = self.key_store[key_id]        old_key_data["status"] = "inactive"        new_key_id = f"{key_id}_rotated_{os.urandom(4).hex()}"        if old_key_data["type"] == "PQC":            self.generate_pqc_key_pair(new_key_id, old_key_data["algorithm"])        elif old_key_data["type"] == "symmetric":            self.generate_symmetric_key(new_key_id, len(bytes.fromhex(old_key_data["key"])))        else:            raise ValueError("Unsupported key type for rotation.")                self._save_key_store()        return new_key_id    def revoke_key(self, key_id: str):        """        Revokes a key by marking it as revoked.        """        if key_id not in self.key_store:            raise ValueError(f"Key with ID {key_id} not found.")        self.key_store[key_id]["status"] = "revoked"        self._save_key_store()    def perform_hybrid_key_exchange_with_kms(self, recipient_pqc_public_key: bytes) -> tuple[bytes, bytes, bytes]:        """        Performs a hybrid key exchange using KMS-managed keys.        Returns the derived session key, Kyber ciphertext, and Kyber encapsulated secret.        """        qkd_shared_key, kyber_ciphertext, kyber_encapsulated_secret, _ = self.hybrid_crypto.hybrid_key_exchange()        if qkd_shared_key is None:            raise Exception("Hybrid key exchange failed due to QKD eavesdropping.")        # In a real scenario, the recipient_pqc_public_key would be used to encapsulate        # the Kyber secret. For this simulation, we're using the one generated internally        # by hybrid_key_exchange for demonstration purposes.                # Derive a final session key from both QKD and Kyber secrets        combined_secret = qkd_shared_key + kyber_encapsulated_secret        salt = os.urandom(16)        info = b"kms-derived-session-key"        session_key = self.hybrid_crypto._derive_key(combined_secret, salt, info, 32) # 32 bytes for AES-256                return session_key, kyber_ciphertext, kyber_encapsulated_secretif __name__ == "__main__":    print("Running KMS Example:")    kms = KMS(master_password="mysecurepassword")    # Generate PQC Key Pair    print("\n--- Generating PQC Key Pair ---")    pqc_key_id = "my_kyber_key"    pqc_keys = kms.generate_pqc_key_pair(pqc_key_id, "Kyber")    print(f"Generated Kyber Key Pair for {pqc_key_id}: Public Key (first 10 bytes) {pqc_keys["public_key"][:10]}...")    retrieved_pqc_key = kms.get_key(pqc_key_id)    print(f"Retrieved Kyber Key Status: {retrieved_pqc_key["status"]}")    # Generate Symmetric Key    print("\n--- Generating Symmetric Key ---")    sym_key_id = "my_aes_key"    symmetric_key = kms.generate_symmetric_key(sym_key_id)    print(f"Generated Symmetric Key for {sym_key_id}: {symmetric_key[:10]}...")    retrieved_sym_key = kms.get_key(sym_key_id)    print(f"Retrieved Symmetric Key Status: {retrieved_sym_key["status"]}")    # Rotate PQC Key    print("\n--- Rotating PQC Key ---")    new_pqc_key_id = kms.rotate_key(pqc_key_id)    print(f"Rotated {pqc_key_id} to new ID: {new_pqc_key_id}")    old_pqc_key_status = kms.get_key(pqc_key_id)["status"]    new_pqc_key_status = kms.get_key(new_pqc_key_id)["status"]    print(f"Old Kyber Key Status ({pqc_key_id}): {old_pqc_key_status}")    print(f"New Kyber Key Status ({new_pqc_key_id}): {new_pqc_key_status}")    # Revoke Symmetric Key    print("\n--- Revoking Symmetric Key ---")    kms.revoke_key(sym_key_id)    revoked_sym_key_status = kms.get_key(sym_key_id)["status"]    print(f"Revoked Symmetric Key Status ({sym_key_id}): {revoked_sym_key_status}")    # Perform Hybrid Key Exchange using KMS    print("\n--- Performing Hybrid Key Exchange with KMS ---")    # For demonstration, we'll use a dummy public key for the recipient    # In a real scenario, this would be the actual public key of the other party    dummy_recipient_pk = b'\x00' * 32 # Placeholder    try:        session_key_kms, ct_kms, ss_kms = kms.perform_hybrid_key_exchange_with_kms(dummy_recipient_pk)        print(f"KMS-derived Session Key (first 10 bytes): {session_key_kms[:10]}...")        print("Hybrid Key Exchange with KMS successful.")    except Exception as e:        print(f"Hybrid Key Exchange with KMS failed: {e}")    # Clean up (optional)    # os.remove("kms_key_store.json")    # print("Cleaned up kms_key_store.json")